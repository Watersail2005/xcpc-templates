<snippet>
	<content><![CDATA[
int root[N],tot,cnt;
struct t1
{
	int l,r;
	long long v;
	t1()
	{
		l=r=v=0;
	}
}t[100*1024*1024/16];
void build(int &p,int l,int r)
{
	if(!p)
	{
		p=++tot;
	}
	if(l==r)
	{
		t[p].v=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(t[p].l,l,mid);
	build(t[p].r,mid+1,r);
	t[p].v=t[t[p].l].v+t[t[p].r].v;
}
void split(int &p,int &q,int l,int r,int u,int v)
{
	if(!q)
	{
		q=++tot;
	}
	if(u<=l&&v>=r)
	{
		t[q]=t[p];
		p=0;
		return;
	}
	int mid=(l+r)>>1;
	if(u<=mid)
	{
		split(t[p].l,t[q].l,l,mid,u,v);
	}
	if(v>mid)
	{
		split(t[p].r,t[q].r,mid+1,r,u,v);
	}
	t[p].v=t[t[p].l].v+t[t[p].r].v;
	t[q].v=t[t[q].l].v+t[t[q].r].v;
}
int merge(int p,int q,int l,int r)
{
	if(!p)
	{
		return q;
	}
	if(!q)
	{
		return p;
	}
	if(l==r)
	{
		t[p].v+=t[q].v;
		return p;
	}
	int mid=(l+r)>>1;
	t[p].l=merge(t[p].l,t[q].l,l,mid);
	t[p].r=merge(t[p].r,t[q].r,mid+1,r);
	t[p].v=t[t[p].l].v+t[t[p].r].v;
	return p;
}
void change(int &p,int l,int r,int x,int k)
{
	if(!p)
	{
		p=++tot;
	}
	if(l==r)
	{
		t[p].v+=k;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		change(t[p].l,l,mid,x,k);
	}
	else
	{
		change(t[p].r,mid+1,r,x,k);
	}
	t[p].v=t[t[p].l].v+t[t[p].r].v;
}
long long ask0(int p,int l,int r,int u,int v)
{
	if(!p)
	{
		return 0;
	}
	if(u<=l&&v>=r)
	{
		return t[p].v;
	}
	int mid=(l+r)>>1;
	long long va=0;
	if(u<=mid)
	{
		va+=ask0(t[p].l,l,mid,u,v);
	}
	if(v>mid)
	{
		va+=ask0(t[p].r,mid+1,r,u,v);
	}
	return va;
}
int ask1(int p,int l,int r,int k)
{
	if(!p)
	{
		return -1;
	}
	if(l==r)
	{
		return l;
	}
	int mid=(l+r)>>1;
	if(k<=t[t[p].l].v)
	{
		return ask1(t[p].l,l,mid,k);
	}
	else
	{
		return ask1(t[p].r,mid+1,r,k-t[t[p].l].v);
	}
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>dseg</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
</snippet>
